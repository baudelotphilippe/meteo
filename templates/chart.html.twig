{% extends 'base.html.twig' %}

{% block body %}
	<h1 class="text-center my-4">Températures horaires par fournisseur</h1>

	<div class="container text-center mb-4">
		{% set providers = chartsData|keys %}
{% set colors = {
  'Met.no': { border: '#F28B82', background: 'rgba(242, 139, 130, 0.4)' },
  'Open-Meteo': { border: '#A7C7E7', background: 'rgba(167, 199, 231, 0.4)' },
  'OpenWeather': { border: '#FFD180', background: 'rgba(255, 209, 128, 0.4)' },
  'WeatherAPI': { border: '#C5E1A5', background: 'rgba(197, 225, 165, 0.4)' },
} %}


		{% for provider in providers %}
			<button type="button" data-source="{{ loop.index0 }}" class="toggle-dataset btn btn-primary mx-1 active">
				{{ provider }}
			</button>
		{% endfor %}
	</div>

	<div style="position: relative; width: 100%; max-width: 800px; height: 400px; margin: 0 auto;">
		<canvas id="combined-chart"></canvas>
	</div>

	 <script>
    const allLabels = [];
    for(let h = 0; h <= 24; h++) {
      allLabels.push(h + 'h');
    }
	
		    // Fonction pour aligner les données d’un dataset sur allLabels
		    function alignData(labelsSource, dataSource, allLabels) {
		      return allLabels.map(label => {
		        const idx = labelsSource.indexOf(label);
		        return idx !== -1 ? dataSource[idx] : null;
		      });
		    }
		
		    // Construire datasets alignés sur allLabels
		    const datasets = [
		      {% for provider in providers %}
		      {
		        label: '{{ provider }}',
		        data: alignData({{ chartsData[provider].labels|json_encode|raw }}, {{ chartsData[provider].temperatures|json_encode|raw }}, allLabels),
	        borderColor: '{{colors[provider].border}}',
	        backgroundColor: '{{colors[provider].background}}',
		        fill: true,
		        tension: 0.3,
		        pointRadius: 4,
		        spanGaps: true, 
		        hidden: false,
		      }{% if not loop.last %},{% endif %}
		      {% endfor %}
		    ];
		
		    const ctx = document.getElementById('combined-chart').getContext('2d');
		
		    const annotationPlugin = window['chartjs-plugin-annotation'];
		    Chart.register(annotationPlugin);
		
		    const now = new Date();
		    const currentDecimal = now.getHours() + now.getMinutes() / 60;
		
		    let xNow = null;
		    const hours = allLabels.map(l => parseInt(l.split('h')[0]));
		    for (let i = 0; i < hours.length - 1; i++) {
		      const h1 = hours[i], h2 = hours[i+1];
		      if (currentDecimal >= h1 && currentDecimal <= h2) {
		        const ratio = (currentDecimal - h1) / (h2 - h1);
		        xNow = i + ratio;
		        break;
		      }
		    }
		    const annotations = xNow !== null ? {
		      nowLine: {
		        type: 'line',
		        xMin: xNow,
		        xMax: xNow,
		        borderColor: 'red',
		        borderWidth: 2,
		      }
		    } : {};
		
		    const chart = new Chart(ctx, {
		      type: 'line',
		      data: {
		        labels: allLabels,
		        datasets: datasets,
		      },
		      options: {
		        responsive: true,
		        maintainAspectRatio: false,
		        scales: {
		          x: { ticks: { autoSkip: false } },
		          y: { min: 0, max: 40 }
		        },
		        plugins: {
		          legend: { display: true },
		          annotation: { annotations: annotations }
		        }
		      }
		    });
		
		    // Boutons toggle pour afficher/cacher datasets
		    document.querySelectorAll('.toggle-dataset').forEach(button => {
		      button.addEventListener('click', () => {
		        const idx = parseInt(button.getAttribute('data-source'), 10);
		        const meta = chart.getDatasetMeta(idx);
		        meta.hidden = !meta.hidden;
		        chart.update();
		        button.classList.toggle('active');
		      });
		    });
		  </script>
{% endblock %}
